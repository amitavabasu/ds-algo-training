package training.backtracking;

import java.util.Arrays;

public class BackTrackingSudokuSolution {

    /*
    This method calculates and returns the box id from 0 to 8 given rows and column numbers coming in 0 to 8.
     */
    public static int getBoxId(int row, int col) {
        int blockCol = (int)Math.floor(col / 3); //first calculate block column in 0, 1, 2 from the given column value 0-8
        int blocksRow = (int)Math.floor(row / 3) * 3;//second calculate the block row in 0, 3, 6 from given row value 0-8
        return blocksRow + blockCol;//add the box-row and box-column value to get boxId.
    }
    /*
    This method checks if a generated number (1-9) [value] is valid for a given cell on the board specified by row (0-8) & column (0-8) value
    Given the existing rows columns and blocks boolean array of 9 X 9 dimension. Where first 9 are 9 rows or 9 columns or 9 blocks
    and last 9 is existence of a number from 0-8.
    Because values come in 1-9 but existence of number index as 0-8 we need to use [value-1]
     */
    public static boolean isValid(int r, int c, int value, boolean[][] rows, boolean[][] cols, boolean[][] blocks) {
        if (rows[r][value-1] || cols[c][value-1] || blocks[getBoxId(r, c)][value-1]) { // check if this value exists
            return false; //if exists in any of the boolean 2D array then the value is not valid, so return false
        } else {
            return true;//if the given value does not exist in any of the 2D array then the value can be accepted, so return true
        }
    }

    /*
    This is the top level method to prepare all required data-structures
    and calling the recursive algorithm to solve the sudoku problem
     */
    public static void solveSudoku(int n, int[][] board) {
        boolean[][] rows = new boolean[n][n];//define array to hold boolean value 1-9 for each row indexed from 0-8
        boolean[][] columns = new boolean[n][n];//define array to hold boolean value 1-9 for each column indexed from 0-8
        boolean[][] blocks = new boolean[n][n];//define array to hold boolean value 1-9 for each box indexed from 0-8
        for (int i = 0; i < n; i++) {//traverse the entire board row, column basis starting row i=0 to i=8
            for (int j = 0; j < n; j++) { //column starting j=0 to j=8
                if(board[i][j] != 0) {//if there exist a number at board cell [i,j] other than 0 then we need to build the row, column, box setting the existence of that number
                    rows[i][board[i][j]-1] = true;//row uses i & board value - 1 as the index of that number on the board
                    columns[j][board[i][j]-1] = true;// columns uses j & board value - 1 as the index of that number on the board
                    blocks[getBoxId(i, j)][board[i][j]-1] = true; //box id is generated by calling getBoxId(row, column) and board value - 1 as the index of that number on the board
                }
            }
        }
        recursivelySolve(n, board, rows, columns, blocks, 0, 0);//Call recursive method to solve sudoku pass dimension n, board, rows verification-array
        //columns verification-array, box verification-array and starting row and column as 0.
    }
    public static boolean recursivelySolve(int n, int[][] board, boolean[][] rows, boolean[][] columns, boolean[][] blocks, int r, int c) {
        if (r == n-1 && c == n-1) return true; // if row and column have reached end, means this game is successfully over, so return true.
        if (r == 1) {
            System.out.println("");
        }
        if (board[r][c] == 0) { //process only if current board value at current cell [r,c] is 0. otherwise there exist a number which cannot be changed do go to next cell
            for (int value = 1; value <= 9; value++) { //generate a possible value for the current cell to try
                board[r][c] = value; // assign the generated value to appropriate position in the board.
                if (isValid(r, c, value, rows, columns, blocks)) { // check if this generated value is acceptable or not in the specific position on the boar
                    //if acceptable
                    rows[r][value-1] = true;//set row boolean field true for the specific value at specific place
                    columns[c][value-1] = true;//set column boolean field true for the specific value at specific place
                    blocks[getBoxId(r, c)][value-1] = true;//set box boolean field true for the specific value at specific place
                    //calculate next cell in separate variables because if backtracking happens we should not change current values passed to this method via call stack
                    int rBar;
                    int cBar;
                    if (c == 8) { // if column reached end increment row and set col back to 0
                        rBar = r + 1;
                        cBar = 0;
                    } else { //otherwise keep row same increment column
                        rBar = r;
                        cBar = c + 1;
                    }
                    //Now call recursively with newly calculated row, column, rows, columns, boxes and modified board.
                    if(recursivelySolve(n, board, rows, columns, blocks, rBar, cBar)) return true;//if recursion successful we need to return true
                    //<-- if recursion fails back tracking starts here
                    //Now while backtracking below statements will execute to revert back the changes made in this iteration
                    rows[r][value-1] = false; //reset back rows value in appropriate place
                    columns[c][value-1] = false;//reset back columns value in appropriate place
                    blocks[getBoxId(r, c)][value-1] = false;//reset back boxes value in appropriate place
                }
                board[r][c] = 0;//if the generated board value is invalid and cannot be accepted here reset back the value to 0 for backtracking
            }//end of checking that current cell value defined by row & column is 0
        } else {//if the current row and column value is not zero this cell is already populated so move to next cell, again using extra variables to keep the current row (r)
            //and column value (c) intact. use rBar and cBar
            int rBar;
            int cBar;
            if (c == 8) {//if column reached end of column which is 8
                rBar = r + 1; // increment row value
                cBar = 0;//reset column value to 0
            } else {//if column has not reached end
                rBar = r; //keep row at the same level
                cBar = c + 1;//increment column
            }
            if(recursivelySolve(n, board, rows, columns, blocks, rBar, cBar)) return true;//call recursively to solve the next row column as generated in rBar & cBar variables
        }//end of current cell value check
        return false;//at this point all generated values 1-9 have failed to be a valid value for the cell. Initiate backtracking by returning false.
    }

    public static void main (String[] args) {
        int n = 9;
        int[][] board = new int[n][n];

        board[0][0] = 9;
        board[0][1] = 8;
        board[0][2] = 7;
        board[8][8] = 1;
        board[8][7] = 2;
        board[8][6] = 3;


        solveSudoku(n, board);

        for (int i = 0; i < n; i++) {
            System.out.println(Arrays.toString(board[i]));
        }
    }
}
